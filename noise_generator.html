<!DOCTYPE html>
<html>

<head>
    <title>White Noise Generator with Filters and Controls v0.6.1</title>
    <link href="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.css" rel="stylesheet">
    <style>
        /* Style definitions */
        body {
            background-color: #000;
            color: #fff;
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 0;
            padding: 30px;
        }

        #controls {
            display: flex;
            justify-content: space-between;
            /* This will space out the child elements evenly */
            flex-wrap: nowrap;
        }

        .slider-container {
            height: 200px;
            margin-top: 10px;

        }

        .slider-wrapper {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            margin: 20px;
            width: 30px;

        }

        .slider-wrapper label {
            align-self: flex-start;
            text-align: right;
            width: 100%;
            margin-bottom: 5px;
            order: -1;
        }


        .noUi-base {
            height: 100%;
            width: 100%;
        }

        .noUi-marker {
            opacity: 0.6;
        }

        .noUi-handle {
            cursor: pointer;
            border: 2px solid #333;
            /* Darker border for contrast */
            box-shadow: 0 0 5px 0 rgba(0, 0, 0, 0.6);
            /* Add shadow for depth */
            background-color: #bdbdbd;
            /* Light background */
            border-radius: 8px;
            /* Adjust this value to round the corners as desired */
        }

        .noUi-tooltip {
            padding: 1px;
            /* Use a smaller value to reduce whitespace */
        }


        button {
            font-size: 1.2em;
            padding: 10px 20px;
            margin: 10px;
        }
    </style>
</head>

<body>
    <div id="controls"></div>
    <div>
        <input type="radio" id="whiteNoise" name="noiseType" value="white" checked>
        <label for="whiteNoise">White Noise</label><br>
        <input type="radio" id="pinkNoise" name="noiseType" value="pink">
        <label for="pinkNoise">Pink Noise</label><br>
        <input type="radio" id="brownNoise" name="noiseType" value="brown">
        <label for="brownNoise">Brown Noise</label>
    </div>
    <button id="audioButton" onclick="toggleAudio()">Initialize Audio</button>
    <button onclick="resetBands(0)" disabled>Reset Bands to 0</button>
    <button onclick="resetBands(0.5)" disabled>Center Bands</button>
    <button onclick="adjustBands(-0.1)" disabled>Decrease All</button>
    <button onclick="adjustBands(0.1)" disabled>Increase All</button>

    <script src="https://cdn.jsdelivr.net/npm/nouislider/distribute/nouislider.min.js"></script>

    <script>
        var context;
        var noiseProcessor, gainNodes = [], isPlaying = false;
        var currentNoiseType = 'white';
        var frequencyBands = [
            [20, 39], [39, 79], [79, 158], [158, 316], [316, 632],
            [632, 1261], [1261, 2517], [2517, 5023], [5023, 10023], [10023, 20000]
        ];
        var settings = JSON.parse(localStorage.getItem('noiseSettings')) || { white: [], pink: [], brown: [] };

        document.querySelectorAll('input[name="noiseType"]').forEach(function (radio) {
            radio.addEventListener('change', function () {
                currentNoiseType = this.value;
                loadSettings();
                if (isPlaying) {
                    playNoise();
                }
            });
        });

        function createBandpassFilter(lowFreq, highFreq) {
            var filter = context.createBiquadFilter();
            filter.type = 'bandpass';
            filter.frequency.value = (lowFreq + highFreq) / 2;
            filter.Q.value = filter.frequency.value / (highFreq - lowFreq);
            return filter;
        }

        function toggleAudio() {
            if (!context) {
                context = new AudioContext();
            }

            var buttons = document.querySelectorAll('button:not(#audioButton)'); // Select all buttons except for the audio button
            if (!isPlaying) {
                playNoise();
                document.getElementById("audioButton").innerText = "Stop Audio";
                isPlaying = true;
                // Enable other buttons
                buttons.forEach(function (button) {
                    button.disabled = false;
                });
            } else {
                stopNoise();
                document.getElementById("audioButton").innerText = "Initialize Audio";
                isPlaying = false;
                // Disable other buttons
                buttons.forEach(function (button) {
                    button.disabled = true;
                });
            }
        }



        function playNoise() {
            if (!noiseProcessor || noiseProcessor.context.state === 'closed') {
                noiseProcessor = context.createScriptProcessor(4096, 1, 1);
            }
            noiseProcessor.onaudioprocess = function (e) {
                var output = e.outputBuffer.getChannelData(0);
                for (var i = 0; i < output.length; i++) {
                    if (currentNoiseType === 'white') {
                        output[i] = generateWhiteNoise();
                    } else if (currentNoiseType === 'pink') {
                        output[i] = generatePinkNoise(i);
                    } else if (currentNoiseType === 'brown') {
                        output[i] = generateBrownNoise(i);
                    }
                }
            };

            setupGainNodes(); // Set up or re-establish the connections with gain nodes
        }

        function setupGainNodes() {
            gainNodes.forEach(function (gainNode) {
                gainNode.disconnect();
            });
            gainNodes = [];

            frequencyBands.forEach(function (band, index) {
                var filter = createBandpassFilter(band[0], band[1]);
                var gainNode = context.createGain();
                gainNodes[index] = gainNode;

                noiseProcessor.connect(filter);
                filter.connect(gainNode);
                gainNode.connect(context.destination);

                var savedValue = settings[currentNoiseType][index];
                gainNode.gain.value = savedValue !== undefined ? parseFloat(savedValue) : 0.5;
            });
        }

        function generateWhiteNoise() {
            return Math.random() * 2 - 1;
        }

        function generatePinkNoise(index) {
            // Basic pink noise generator using a series of low-pass filters
            // You might need a more complex algorithm for accurate pink noise generation
            var b0, b1, b2, b3, b4, b5, b6;
            b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;
            var white = Math.random() * 2 - 1;
            b0 = 0.99886 * b0 + white * 0.0555179;
            b1 = 0.99332 * b1 + white * 0.0750759;
            b2 = 0.96900 * b2 + white * 0.1538520;
            b3 = 0.86650 * b3 + white * 0.3104856;
            b4 = 0.55000 * b4 + white * 0.5329522;
            b5 = -0.7616 * b5 - white * 0.0168980;
            var pink = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;
            pink *= 0.11; // Adjust to proper level
            b6 = white * 0.115926;
            return pink;
        }

        function generateBrownNoise(index) {
            return Math.random() * 2 - 1;
        }

        function stopNoise() {
            if (noiseProcessor) {
                noiseProcessor.disconnect();
                noiseProcessor = null;
                gainNodes.forEach(function (gainNode) {
                    gainNode.disconnect();
                });
                gainNodes = [];
            }
        }

        function resetBands(value) {
            for (var i = 0; i < frequencyBands.length; i++) {
                setSliderValue(i, value);
            }
            saveSettings();
        }

        function adjustBands(delta) {
            for (var i = 0; i < frequencyBands.length; i++) {
                var currentValue = gainNodes[i] ? gainNodes[i].gain.value : 0.5;
                setSliderValue(i, Math.max(0, Math.min(1, currentValue + delta)));
            }
            saveSettings();
        }
        var colors = [
            "#8B0000", // Deep Red
            "#FF4500", // Red-Orange
            "#FFA500", // Orange
            "#FFD700", // Gold-Yellow
            "#FFFF00", // Light Yellow
            "#ADFF2F", // Light Green
            "#7FFFD4", // Aquamarine
            "#87CEEB", // Sky Blue
            "#4169E1", // Royal Blue
            "#8A2BE2"  // Violet
        ];


        function saveSettings() {
            var currentSettings = settings[currentNoiseType] || [];
            frequencyBands.forEach(function (_, index) {
                var sliderElement = document.getElementById('slider' + index);
                if (sliderElement && sliderElement.noUiSlider) {
                    currentSettings[index] = sliderElement.noUiSlider.get();
                }
            });
            settings[currentNoiseType] = currentSettings;
            localStorage.setItem('noiseSettings', JSON.stringify(settings));
        }


        function loadSettings() {
            var savedSettings = settings[currentNoiseType];
            if (savedSettings) {
                savedSettings.forEach(function (value, index) {
                    var sliderElement = document.getElementById('slider' + index);
                    if (sliderElement && sliderElement.noUiSlider) {
                        sliderElement.noUiSlider.set(value);
                    }
                });
            }
        }


        function setSliderValue(index, value) {
            var sliderElement = document.getElementById('slider' + index);
            if (sliderElement && sliderElement.noUiSlider) {
                // Temporarily remove the event listener to avoid triggering it
                sliderElement.noUiSlider.off('update');
                sliderElement.noUiSlider.set(value);
                // Re-attach the event listener
                sliderElement.noUiSlider.on('update', noUiSliderUpdateHandler(index));
            }
        }

        function noUiSliderUpdateHandler(index) {
            return function (values, handle) {
                var value = parseFloat(values[handle]);
                if (gainNodes[index]) {
                    gainNodes[index].gain.value = value;
                }
            };
        }

        frequencyBands.forEach(function (band, index) {
            // Container for both the label and the slider
            var sliderWrapper = document.createElement('div');
            sliderWrapper.className = 'slider-wrapper';
            sliderWrapper.style.textAlign = 'center'; // Center align the label text

            // Create a label for each frequency band
            var label = document.createElement('label');
            label.innerHTML = band[0] + '-<br>' + band[1] + '<br>Hz';
            label.style.color = colors[index];
            label.style.marginBottom = '10px'; // Add space below the label

            // Append the label to the wrapper
            sliderWrapper.appendChild(label);

            // Create the slider container and append it to the wrapper
            var container = document.createElement('div');
            container.className = 'slider-container';
            container.id = 'slider' + index;
            sliderWrapper.appendChild(container);

            // Append the whole wrapper to the controls container
            document.getElementById('controls').appendChild(sliderWrapper);

            noUiSlider.create(container, {
                start: settings[currentNoiseType][index] !== undefined ? settings[currentNoiseType][index] : 0.5,
                orientation: 'vertical',
                direction: 'rtl',
                range: {
                    'min': 0,
                    'max': 1
                },
                pips: {
                    mode: 'steps',
                    density: 5, // Adjust density for more or fewer tick marks

                },
                connect: [true, false], // Color the lower part of the slider
                tooltips: true, // Enable tooltips to display the current value
                format: {
                    to: function (value) {
                        return value.toFixed(2);
                    },
                    from: function (value) {
                        return Number(value);
                    }
                }
            });

            // Set the color of the entire slider track
            container.noUiSlider.on('update', function (values, handle, unencoded, isTap, positions) {
                var value = parseFloat(values[handle]);
                if (gainNodes[index]) {
                    gainNodes[index].gain.value = value;
                    // If needed, trigger audio processing here
                }
                var connectBar = this.target.querySelector('.noUi-connect');
                var base = this.target.querySelector('.noUi-base');

                if (base) {
                    base.style.backgroundColor = 'darkgrey'; // This sets the "unused" portion
                }
                if (connectBar) {
                    connectBar.style.backgroundColor = colors[index]; // This sets the "used" portion
                }
            });

            // Save settings when the slider value changes
            container.noUiSlider.on('change', function (values, handle) {
                saveSettings();
            });
        });

        window.onload = function () {
            setupSliders();
            loadSettings();
        };
    </script>
</body>

</html>